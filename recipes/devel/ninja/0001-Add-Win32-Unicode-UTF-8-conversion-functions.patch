diff --git a/src/util.cc b/src/util.cc
index 7000a6ad12..9ea77eaacb 100644
--- a/src/util.cc
+++ b/src/util.cc
@@ -560,7 +560,55 @@ void Win32Fatal(const char* function, const char* hint) {
     Fatal("%s: %s", function, GetLastErrorString().c_str());
   }
 }
-#endif
+
+bool ConvertUTF8ToWin32Unicode(const std::string& input, std::wstring* output,
+                               std::string* err) {
+  output->clear();
+  if (input.empty())
+    return true;
+
+  int int_size = static_cast<int>(input.size());
+  if (static_cast<size_t>(int_size) != input.size()) {
+    *err = "Input string length > INT_MAX";
+    return false;
+  }
+  int wide_size =
+      MultiByteToWideChar(CP_UTF8, 0, input.c_str(), int_size, nullptr, 0);
+  if (wide_size <= 0) {
+    *err = "MultiByteToWideChar(" + input + "): " + GetLastErrorString();
+    return false;
+  }
+  output->resize(static_cast<size_t>(wide_size));
+  MultiByteToWideChar(CP_UTF8, 0, input.c_str(), int_size,
+                      const_cast<wchar_t*>(output->data()), wide_size);
+  return true;
+}
+
+bool ConvertWin32UnicodeToUTF8(const std::wstring& input, std::string* output,
+                               std::string* err) {
+  output->clear();
+  if (input.empty())
+    return true;
+
+  int int_size = static_cast<int>(input.size());
+  if (int_size != input.size()) {
+    *err = "Input string length > INT_MAX";
+    return false;
+  }
+  int utf8_size = WideCharToMultiByte(CP_UTF8, 0, input.c_str(), int_size, NULL,
+                                      0, NULL, NULL);
+  if (utf8_size <= 0) {
+    *err = "WideCharToMultiByte(" + std::string(input.begin(), input.end()) +
+           "): " + GetLastErrorString();
+    return false;
+  }
+
+  output->resize(static_cast<size_t>(utf8_size));
+  WideCharToMultiByte(CP_UTF8, 0, input.c_str(), int_size,
+                      const_cast<char*>(output->data()), utf8_size, NULL, NULL);
+  return true;
+}
+#endif  // _WIN32
 
 bool islatinalpha(int c) {
   // isalpha() is locale-dependent.
diff --git a/src/util.h b/src/util.h
index 02c2418396..40b07b68e1 100644
--- a/src/util.h
+++ b/src/util.h
@@ -124,6 +124,18 @@ std::string GetLastErrorString();
 /// Calls Fatal() with a function name and GetLastErrorString.
 NORETURN void Win32Fatal(const char* function, const char* hint = NULL);
 
+/// Convert UTF-8 string to Win32 Unicode.
+/// On success, set |*output| then return true.
+/// On Failure, clear |*output|, set |*err| then return false.
+bool ConvertUTF8ToWin32Unicode(const std::string& input, std::wstring* output,
+                               std::string* err);
+
+/// Convert WIN32 Unicode to UTF-8 string.
+/// On success, set |*output| then return true.
+/// On Failure, clear |*output|, set |*err| then return false.
+bool ConvertWin32UnicodeToUTF8(const std::wstring& input, std::string* output,
+                               std::string* err);
+
 /// Naive implementation of C++ 20 std::bit_cast(), used to fix Clang and GCC
 /// [-Wcast-function-type] warning on casting result of GetProcAddress().
 template <class To, class From>
diff --git a/src/util_test.cc b/src/util_test.cc
index 38e65e9338..f154cae442 100644
--- a/src/util_test.cc
+++ b/src/util_test.cc
@@ -502,3 +502,25 @@ TEST(StripAnsiEscapeCodes, StripColors) {
   EXPECT_EQ("affixmgr.cxx:286:15: warning: using the result... [-Wparentheses]",
             stripped);
 }
+
+#ifdef _WIN32
+TEST(ConvertWin32UnicodeToUTF8, Test) {
+  std::string output;
+  std::string err;
+  EXPECT_TRUE(ConvertWin32UnicodeToUTF8(std::wstring(L"B\u00E9b\u00E9"),
+                                        &output, &err));
+  EXPECT_TRUE(err.empty()) << err;
+  EXPECT_EQ(output, std::string("B\xC3\xA9"
+                                "b\xC3\xA9"));
+}
+
+TEST(ConvertUTF8ToWin32Unicode, Test) {
+  std::string err;
+  std::wstring output;
+  EXPECT_TRUE(ConvertUTF8ToWin32Unicode(std::string("B\xC3\xA9"
+                                                    "b\xC3\xA9"),
+                                        &output, &err));
+  EXPECT_TRUE(err.empty()) << err;
+  EXPECT_EQ(output, std::wstring(L"B\u00E9b\u00E9"));
+}
+#endif  // _WIN32
